<?php
namespace {{ namespace }}\Models\Base;
use \{{ namespace }}\{{ namespace }};
use \Zenderator\Abstracts\Model as AbstractModel;
use \{{ namespace }}\Services;
use \{{ namespace }}\Models;

abstract class Base{{ class_name }}Model extends AbstractModel
{

{% if primary_keys %}
    protected $_primary_keys = ['{{ primary_keys|join('\', \'')|raw }}'];
{% endif %}

{% for column in columns %}
    private ${{ column.field }};
{% endfor %}

{% for column in columns %}
    public function get{{ column.field }}() {% if column.phptype %}/* Sadly can't use this until nullable return types turns up. : {{ column.phptype }} */{% endif %}
    {
        return $this->{{ column.field }};
    }

    public function set{{ column.field }}({{ column.phptype }} ${{ column.field }} = null)
    {
        $this->{{ column.field }} = ${{ column.field }};
        return $this;
    }
{% if 'constraints' in column|keys %}

    public function fetch{{ column.field }}Object() : Models\{{ column.constraints.remote_model_class }}Model
    {
        ${{ column.constraints.remote_model_class }}Service = {{ namespace }}::Container()->get(Services\{{ column.constraints.remote_model_class }}Service::class);
        #${{ column.constraints.remote_model_class }}Service = new Services\{{ column.constraints.remote_model_class }}Service();
{% if column.constraints.remote_model_key == 'id' %}
        return ${{ column.constraints.remote_model_class }}Service->getById($this->get{{ column.field }}());
{% else %}
        return ${{ column.constraints.remote_model_class }}Service->getByField('{{ column.constraints.remote_model_key }}', $this->get{{ column.field }}());
{% endif %}
    }
{% endif %}

{% endfor %}

    // TODO: Write a lazy convenience function here that gets the correct
    // TableGateway out of DI and saves $this through it.
    #public function save()
    #{
    #
    #}
}